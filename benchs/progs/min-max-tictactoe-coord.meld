
type linear play(node, list int, int, int, int).
type linear check-if-end(node, list int, int, int, int, list list int).
type linear root(node).
type linear build-next-plays(node, list int, list int, int, int, int, int, int).
type linear leaf(node, list int, int, int).
type linear back(node, node).
type linear evaluate-wins(node, list int, int, list list int, int).
type linear evaluate-win(node, list int, int, list int, list list int, int).
type linear count-points(node, list int, int, int, int).
type linear score(node, int, int).
type linear new-score(node, int, int).
type linear maximize(node, int, int, int).
type linear minimize(node, int, int, int).
type linear depth(node, int).

const maxinf = 9999.
const mininf = -9999.
const maxdepth = 999.

play(@0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 1, 0, 1).
root(@0).
depth(@0, 1).

play(A, Game, NextPlayer, LastPlay, RootPlayer),
depth(A, Depth),
Depth > maxdepth
   -o leaf(A, Game, RootPlayer, LastPlay),
      depth(A, Depth).

play(A, Game, NextPlayer, LastPlay, RootPlayer)
   -o check-if-end(A, Game, NextPlayer, LastPlay, RootPlayer, [[0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 4, 8], [2, 4, 6]]).

check-if-end(A, Game, NextPlayer, LastPlay, RootPlayer, [])
   -o build-next-plays(A, [], Game, NextPlayer, 0, RootPlayer, 0, LastPlay).
check-if-end(A, Game, NextPlayer, LastPlay, RootPlayer, [[P1, P2, P3] | Xs]),
intlistnth(Game, P2) = intlistnth(Game, P1),
intlistnth(Game, P1) = intlistnth(Game, P3),
intlistnth(Game, P1) <> 0
   -o leaf(A, Game, RootPlayer, LastPlay).
check-if-end(A, Game, NextPlayer, LastPlay, RootPlayer, [X | Xs])
   -o check-if-end(A, Game, NextPlayer, LastPlay, RootPlayer, Xs).

build-next-plays(A, Previous, [], NextPlayer, X, RootPlayer, 0, Play) -o leaf(A, Previous, RootPlayer, Play).
build-next-plays(A, Previous, [], RootPlayer, X, RootPlayer, N, Play), N > 0
   -o maximize(A, N, mininf, 0).
build-next-plays(A, Previous, [], NextPlayer, X, RootPlayer, N, Play), N > 0, NextPlayer <> RootPlayer
   -o minimize(A, N, maxinf, 0).
depth(A, Depth),
build-next-plays(A, Previous, [0 | Xs], NextPlayer, X, RootPlayer, Descendants, Play)
   -o exists B. (play(B, intlistappend(Previous, [NextPlayer | Xs]), if NextPlayer = 1 then 2 else 1 end, X, RootPlayer),
         build-next-plays(A, intlistappend(Previous, [0]), Xs, NextPlayer, X + 1, RootPlayer, Descendants + 1, Play),
         depth(A, Depth),
         depth(B, Depth + 1),
         (if Depth >= 4 then set-priority(B, 1), set-static(B) otherwise 1 end),
         back(B, A)).
build-next-plays(A, Previous, [C | Xs], NextPlayer, X, RootPlayer, Descendants, Play), C <> 0
   -o build-next-plays(A, intlistappend(Previous, [C]), Xs, NextPlayer, X + 1, RootPlayer, Descendants, Play).

leaf(A, Game, RootPlayer, Play)
   -o evaluate-wins(A, Game, RootPlayer, [[0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 4, 8], [2, 4, 6]], Play).

evaluate-wins(A, Game, RootPlayer, [], Play)
   -o count-points(A, Game, RootPlayer, 0, Play).
evaluate-wins(A, Game, RootPlayer, [X | Xs], Play)
   -o evaluate-win(A, Game, RootPlayer, X, Xs, Play).
evaluate-win(A, Game, RootPlayer, [P1, P2, P3], Wins, Play),
intlistnth(Game, P2) = intlistnth(Game, P1),
intlistnth(Game, P1) = intlistnth(Game, P3)
   -o score(A, if intlistnth(Game, P1) = RootPlayer then 200 else -100 end, Play).
evaluate-win(A, Game, RootPlayer, X, Wins, Play) -o evaluate-wins(A, Game, RootPlayer, Wins, Play).

count-points(A, [], RootPlayer, Points, Play) -o score(A, Points, Play).
count-points(A, [RootPlayer | Games], RootPlayer, Points, Play)
   -o count-points(A, Games, RootPlayer, Points + 1, Play).
count-points(A, [X | Xs], RootPlayer, Points, Play), X <> RootPlayer
   -o count-points(A, Xs, RootPlayer, Points, Play).

score(A, Score, BestPlay),
back(A, B),
depth(A, Depth)
   -o new-score(B, Score, BestPlay).

new-score(A, Score, Play),
minimize(A, N, Current, BestPlay),
Current > Score // new best
   -o minimize(A, N - 1, Score, Play).
new-score(A, Score, Play),
minimize(A, N, Current, BestPlay),
Current <= Score
   -o minimize(A, N - 1, Current, BestPlay).
new-score(A, Score, Play),
maximize(A, N, Current, BestPlay),
Current < Score // best
   -o maximize(A, N - 1, Score, Play).
new-score(A, Score, Play),
maximize(A, N, Current, BestPlay),
Current >= Score
   -o maximize(A, N - 1, Current, BestPlay).

minimize(A, 0, Score, BestPlay) -o score(A, Score, BestPlay).
maximize(A, 0, Score, BestPlay) -o score(A, Score, BestPlay).

